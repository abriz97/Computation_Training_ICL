---
title: "Computational Training: running fastR"
format: revealjs
---

## Great R resources 

::: {.nonincremental}
In general: 

1. [Advanced R](https://adv-r.hadley.nz/)
2. [R for Data Science](https://r4ds.hadley.nz/)
3. [RStudio Cheatsheets](https://www.rstudio.com/resources/cheatsheets/)
4. [Useful R packages](https://support.posit.co/hc/en-us/articles/201057987-Quick-list-of-useful-R-packages)

Covering this session's topics

5. [data.table](https://rdatatable.gitlab.io/data.table/)
6. [parallel](https://dept.stat.lsa.umich.edu/~jerrick/courses/stat701/notes/parallel.html#the-parallel-package)
:::


## What is "fast code"?

1.  ‚úèÔ∏è **Easy to write** \
familiarity with code editor, libraries

2. üí° **Easy to understand** \
structured, with consistent variable names, commented.

3. üîß **Easy to debug** \
clear naming, DRY, tests.

4. üèéÔ∏è **Easy to run** \
 (profiling, C++, using "optimized" code).


##  Variable naming

::: {.r-stack}
![](../figures/MagrittePipe.jpg){.fragment height=250 fig-align="center"}

![](../figures/catcat.png){.fragment height=250 fig-align="center"}
:::

. . .

names should be consistent, descriptive, lower case, readable.

. . .

For which snippet is it easier to guess the context? 

::: {.columns}

::: {.column width="50%"}

```{r}
tmp <-  10
tmp1 <- tmp * 24
```

:::

::: {.column width="50%"}
```{r}
cases_per_hour <- 10
cases_per_day <- cases_per_hour * 24
```
:::

:::


::: footer
[Dealing with the 2nd hardest thing in computer science (Patil)](https://indrajeetpatil.github.io/second-hardest-cs-thing/#/dealing-with-the-second-hardest-thing-in-computer-science)
:::

## Embrace functional programming I

*Functions are first-class citizens in R*

::: {.columns}

::: {.column width="57%"}

* can be passed as arguments
* can be returned from other functions
* can be assigned to variables
* and more...

:::

::: {.column width="41%" .fragment}

```{r functional-programming-i }
#| filename: "first-class-citizenship.R"
#| warning: false

f <- function(x){x^2}

lapply(1:10, f)

generator <- function(n=2){
    function(x){x^n}
}
cube <- generator(3)

list(one_function = f)
```

:::

:::


## Embrace functional programming II

*Rethink for, while loops; "apply" instead*

. . .

> ‚ÄúTo become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs.‚Äù
>
> ‚Äî Bjarne Stroustrup


::: footer
[Advanced R, Funtional Programming (Wickham)](https://adv-r.hadley.nz/functionals.html)
:::


. . .

<div style="text-align: right;">**...but why?**</div>

## 

Say you want to extract the $R^2$ from three linear models with different predictors (or formulae).

```{r }
#| filename: "formulae.R"
#| warning: false
formulae <- c(
    Sepal.Length ~ Sepal.Width,
    Sepal.Length ~ Petal.Length,
    Sepal.Length ~ Species
)
```

. . .

::: {.columns}

::: {.column width="50%" .fragment}
```{r for-loop}
#| filename: "bad way"
#| warning: false
lm_results2 <- c()

for (formula in formulae) {
    fit <- lm(formula, data = iris)
    r2 <- summary(fit)$r.squared
    lm_results2 <- c(lm_results2, r2)
}
```
:::

::: {.column width="50%" .fragment}
```{r }
#| filename: "good way"
#| warning: false
extract_r2 <- function(formula) {
    fit <- lm(formula, data = iris)
    r2 <- summary(fit)$r.squared
    return(r2)
}

lm_results <- sapply(formulae, extract_r2)
```
:::


:::

. . .

<div style="text-align: center;">What's the difference?</div>

. . .

```{r}
#| filename: "side effects"
#| warning: false
exists("fit")
```

::: footer
[Advanced R, Functional Programming (Wickham)](https://adv-r.hadley.nz/fp.html)
:::

::: { .notes }
- For loops may still be prefered (or the only choice), when the order of execution is important, and different runs may affect each other.
:::

## The `parallel` package

You can imagine wanting to run each of the apply/for loop iterations in `parallel`.

::: { .notes }
especially if iterations are independent and computationally expensive.
Two quick sentences on the two different approaches.
:::

::: {.columns}

::: {.column width="50%" .fragment}
```{r socket}
#| filename: "sockets (not on Windows)"
#| warning: false

library(parallel)
f <- function(i) {
    lme4::lmer(
        Petal.Width ~ . - Species + (1 | Species),
        data = iris)
}

system.time(save1 <- lapply(1:100, f))
##    user  system elapsed
##   2.048   0.019   2.084
system.time(save2 <- mclapply(1:100, f))
##    user  system elapsed
##   1.295   0.150   1.471
```
:::

::: {.column width="50%" .fragment}
```{r }
#| filename: "forking"
#| warning: false

num_cores <- detectCores()
cl <- makeCluster(num_cores)
system.time(save3 <- parLapply(cl, 1:100, f))
#    user  system elapsed 
#   0.198   0.044   1.032 
stopCluster(cl)
```

* requires further attention

:::

:::


::: footer
[Parallel computing in R](https://dept.stat.lsa.umich.edu/~jerrick/courses/stat701/notes/parallel.html#the-parallel-package)
:::


## Introduction to [data.table](https://rdatatable.gitlab.io/data.table/)

* `data.table` is a package that extends the data.frame class.
* (Quicker) alternative to `dplyr` for large datasets.
* [cheatsheet](https://rstudio.github.io/cheatsheets/datatable.pdf)

## all you need to know

<div style="text-align: center; font-size: 100px;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>

* use the data.table called `dt` ...
* subset it on the rows specified by <span style="color:blue;">i</span>...
* and manipulate columns with <span style="color:red;">j</span>...
* grouped according to <span style="color:green;">by</span>.

. . .

```{r}
#| eval: true
library(data.table)
iris_dt <- as.data.table(iris)
```

## `iris` summaries

#### Subsetting and Summarizing

::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 

::: {.columns}

::: {.column width="50%" .fragment}
* Say we want to  calculate <span style="color:red;">the mean sepal length</span> for the <span style="color:blue;">setosa species</span>...
:::

::: {.column width="50%" .fragment}
```{r}
#| eval: true
iris_dt[Species == "setosa", mean(Sepal.Length)]
```
:::

::: 

#### Grouping and Aggregating
::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 


::: {.columns}

::: {.column width="50%" .fragment}
* Now we want to  <span style="color:red;">repeat the above</span> for <span style="color:green;">every species</span>, in one command.
:::


::: {.column width="50%" .fragment}
```{r}
#| eval: true
iris_dt[, mean(Sepal.Length), by=Species]
```
:::

:::


## `iris` summaries (`.VARS`)
::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 


#### Counting entries (`.N`)

::: {.columns}

::: {.column width="50%" .fragment}
* Count the total <span style="color:red;"> number of observations </span> per <span style="color:green;"> species </span>,  with <span style="color:blue;">sepal length > 5</span>.
:::


::: {.column width="50%" .fragment}
```{r}
#| eval: true
iris_dt[Sepal.Length>5, .N, by=Species]
```
:::

:::

#### Print 1st entry of each group (`.SD`)
::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 


::: {.columns}

::: {.column width="50%" .fragment}
* Print the <span style="color:red;">first entry</span> of each  <span style="color:green;"> group (species) </span>.
:::

::: {.column width="50%" .fragment}

```{r}
#| eval: true
iris_dt[, .SD[1], by=Species]
```
:::


::: footer
`?.I` for documentation on data.table's special symbols.
:::

:::


## Modifying the `dt` (in place)
::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 


#### Define a new column

::: {.columns}

::: {.column width="50%" .fragment}
* Say you want species names to sound more Italian.
:::

::: {.column width="50%" .fragment}

```{r}
#| eval: true
iris_dt[, Species_ita := paste0(
    Species, 'ino'
), by=Species]
iris_dt[, unique(Species_ita)]
```
:::

:::


#### Modify existing column
::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 


::: {.columns}

::: {.column width="50%" .fragment}
* The "aino" ending does not sound right, let's remove the "a".
:::

::: {.column width="50%" .fragment}
```{r}
#| eval: true
iris_dt[, Species_ita := gsub(
    "aino","ino",
    Species_ita
), by=Species_ita]
iris_dt[, unique(Species_ita)]
```
:::

:::

## Acting on multiple columns
::: {.top-right}
<div style="text-align: center;">dt[<span style="color:blue;">i</span>, <span style="color:red;">j</span>, <span style="color:green;">by</span>]</div>
::: 


#### Apply a function to multiple columns

::: {.columns}

::: {.column width="40%" .fragment}
* Let us round the numeric columns to integers...
:::

::: {.column width="60%" .fragment}
```{r }
#| eval:  true
#| warning: false
numeric_cols <- names(iris_dt)[sapply(iris_dt, is.numeric)]
iris_dt[, lapply(
    .SD, as.integer
), .SDcols = numeric_cols] |> head(2)
```
:::

:::


#### Define multiple columns at once

::: {.columns}

::: {.column width="40%" .fragment}
* ... and store them in columns with the same name, but with a `_int` suffix.
:::

::: {.column width="60%" .fragment}
```{r }
#| eval: true
#| warning: false
new_cols <- paste0(numeric_cols, "_int")
iris_dt[, (new_cols) := lapply(
    .SD, as.integer
), .SDcols = numeric_cols]; head(iris_dt, n=2)
```
:::


:::

## Summary and advanced topics

::: {.nonincremental}
* `data.table` is a powerful package for data manipulation.
* quick to write and quick to run BUT not the easiest to read.

Advanced topics:

* Definitely print out a [cheatsheet](https://rstudio.github.io/cheatsheets/datatable.pdf) if you want to start using it.
* [data.table function reference](https://rdatatable.gitlab.io/data.table/reference/index.html) for additional wrangling utilities.
* [Vignettes](https://rdatatable.gitlab.io/data.table/articles/datatable-intro.html) for more advanced topics.
:::

::: {footer}

:::



## Profiling

* Identify (and hopefully fix!) bottlenecks in your code.
* The [`profvis`](https://rstudio.github.io/profvis/) package is a good package to use for this purpose.

![](../figures/profiling.webp){.fragment height=350 fig-align="center"}

## Profiling Example: Column Means

```{r prof}
#| eval: true
#| output-location: slide
library(profvis)
library(data.table)
n <- 4e5
cols <- 150
data <- as.data.frame(x = matrix(rnorm(n * cols, mean = 5), ncol = cols))
data <- cbind(id = paste0("g", seq_len(n)), data)
dataDF <- as.data.table(data)
numeric_vars <- setdiff(names(data), "id")

profvis({
  means <- apply(data[, names(data) != "id"], 2, mean)
  means <- colMeans(data[, names(data) != "id"])
  means <- lapply(data[, names(data) != "id"], mean)
  means <- vapply(data[, names(data) != "id"], mean, numeric(1))
  means <- matrixStats::colMeans2(as.matrix(data[, names(data) != "id"]))
  means <- dataDF[, lapply(.SD, mean), .SDcols = numeric_vars]
})
```

## Profiling




::: { .notes }
 {background-iframe="hello-matrix/index.html"}
let us add this with the hex of data.table at the end.
:::



